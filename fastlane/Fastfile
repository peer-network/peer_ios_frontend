# Fastfile
default_platform(:ios)

platform :ios do
  # ==== Constants (prod defaults) ====
  APP_IDENTIFIER = "eu.peernetwork.PeerApp"
  EXTENSION_IDENTIFIER = "eu.peernetwork.PeerApp.PayloadModification"
  MAIN_TARGET = "PeerApp"
  EXTENSION_TARGET = "PayloadModification"
  SCHEME = "PeerApp"
  OUTPUT_DIR  = "build"
  KEYCHAIN_NAME = "signing"
  KEYCHAIN_PASSWORD = "temp"
  ROOT_DIR = File.expand_path("..", __dir__)
  VERSION_NOTES_PATH_DEFAULT = File.join(ROOT_DIR, "PeerApp", "Embeds", "version_history.json")

  before_all do
    sh("mkdir -p #{OUTPUT_DIR}")
  end

  desc "Load ASC API Key information to use in subsequent lanes"
  lane :load_asc_api_key do
    app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_PRIVATE_KEY"],
      is_key_content_base64: true,
      in_house: false
    )
  end

  desc "Get release notes for current version from JSON"
  lane :notes_from_json do |options|
    require "json"
    target = options[:target] || MAIN_TARGET
    current_version = get_version_number(target: target)

    path = if ENV["VERSION_NOTES_PATH"] && !ENV["VERSION_NOTES_PATH"].empty?
             ENV["VERSION_NOTES_PATH"]
           else
             VERSION_NOTES_PATH_DEFAULT
           end

    unless File.exist?(path)
      UI.important("version_history.json not found at #{path}. Using empty notes.")
      next ""
    end

    json = JSON.parse(File.read(path))
    entry = json.find { |e| e["version"].to_s.strip == current_version.to_s.strip }
    if entry.nil? || entry["releaseNotes"].nil?
      UI.important("No notes found for version #{current_version} in #{path}")
      next ""
    end
    "- " + entry["releaseNotes"].map(&:to_s).join("\n- ")
  end

  private_lane :fetch_and_increment_build_number_for do |options|
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]
    app_identifier = options[:app_identifier]
    target = options[:target] || MAIN_TARGET
    current_version = get_version_number(target: target)

    begin
      latest_build_number = latest_testflight_build_number(
        api_key: api_key,
        version: current_version,
        app_identifier: app_identifier
      )
      new_build_number = latest_build_number ? (latest_build_number + 1) : 1
    rescue => e
      UI.message("Error fetching build number: #{e}, defaulting to 1")
      new_build_number = 1
    end

    increment_build_number(
      build_number: new_build_number.to_s,
      xcodeproj: "#{MAIN_TARGET}.xcodeproj"
    )
  end

  private_lane :prepare_signing_for do |options|
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]
    app_identifier = options[:app_identifier]
    extension_identifier = options[:extension_identifier]
    team_id = ENV["APP_STORE_CONNECT_TEAM_ID"]

    begin
      delete_keychain(name: KEYCHAIN_NAME)
    rescue
    end

    create_keychain(
      name: KEYCHAIN_NAME,
      password: KEYCHAIN_PASSWORD,
      default_keychain: true,
      unlock: true,
      timeout: 3600
    )

    import_certificate(
      certificate_path: ENV["SIGNING_KEY_FILE_PATH"],
      certificate_password: ENV["SIGNING_KEY_PASSWORD"],
      keychain_name: KEYCHAIN_NAME,
      keychain_password: KEYCHAIN_PASSWORD
    )

    sigh(api_key: api_key, team_id: team_id, app_identifier: app_identifier, readonly: false)
    @main_profile_name = lane_context[SharedValues::SIGH_NAME]

    sigh(api_key: api_key, team_id: team_id, app_identifier: extension_identifier, readonly: false)
    @extension_profile_name = lane_context[SharedValues::SIGH_NAME]
  end

  private_lane :build_for do |options|
    scheme = options[:scheme]
    configuration = options[:configuration] || "Release"
    output_name = options[:output_name]
    app_identifier = options[:app_identifier]
    extension_identifier = options[:extension_identifier]

    # explicit code signing for both targets (this pins config-specific settings)
    update_code_signing_settings(
      use_automatic_signing: false,
      targets: [MAIN_TARGET],
      code_sign_identity: "Apple Distribution",
      bundle_identifier: app_identifier,
      profile_name: @main_profile_name,
      build_configurations: [configuration]
    )

    update_code_signing_settings(
      use_automatic_signing: false,
      targets: [EXTENSION_TARGET],
      code_sign_identity: "Apple Distribution",
      bundle_identifier: extension_identifier,
      profile_name: @extension_profile_name,
      build_configurations: [configuration]
    )

    gym(
      scheme: scheme,
      output_name: output_name,
      output_directory: OUTPUT_DIR,
      configuration: configuration,
      clean: true,
      silent: false,
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          app_identifier => @main_profile_name,
          extension_identifier => @extension_profile_name
        }
      }
    )
  end

  private_lane :upload_for do |options|
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]
    notes = notes_from_json(target: MAIN_TARGET)
    ipa_name = options[:output_name]
    distribute_external = options[:distribute_external] || false
    groups = options[:groups] || ENV["INTERNAL_TF_GROUPS"]

    upload_to_testflight(
      api_key: api_key,
      ipa: File.join(OUTPUT_DIR, "#{ipa_name}.ipa"),
      skip_waiting_for_build_processing: false,
      distribute_external: distribute_external,
      groups: groups,
      changelog: notes
    )
  end

  # ====== PROD (existing behaviour) ======

  lane :build_release do
    # preserved for backwards compatibility
    build_for(
      scheme: SCHEME,
      configuration: "Release",
      output_name: "PeerApp",
      app_identifier: APP_IDENTIFIER,
      extension_identifier: EXTENSION_IDENTIFIER
    )
  end

  lane :upload_release do
    upload_for(output_name: "PeerApp", distribute_external: false)
  end

  lane :build_upload_testflight do
    begin
      load_asc_api_key
      prepare_signing_for(
        app_identifier: APP_IDENTIFIER,
        extension_identifier: EXTENSION_IDENTIFIER
      )
      fetch_and_increment_build_number_for(
        app_identifier: APP_IDENTIFIER,
        target: MAIN_TARGET
      )
      build_release
      upload_release
    ensure
      begin
        delete_keychain(name: KEYCHAIN_NAME)
      rescue
      end
    end
  end

  # ====== ALT (manual channel) ======

  desc "Build & upload the ALT flavor to its own TestFlight app"
  lane :build_upload_testflight_alt do |options|
    alt_app_id = "eu.peernetwork.PeerApp.Staging"
    alt_ext_id = "eu.peernetwork.PeerApp.Staging.PayloadModification"
    scheme     = options[:scheme] || "PeerAppStaging"
    config     = options[:configuration] || "Staging"
    output     = "PeerAppStaging"

    begin
      load_asc_api_key
      prepare_signing_for(app_identifier: alt_app_id, extension_identifier: alt_ext_id)
      fetch_and_increment_build_number_for(app_identifier: alt_app_id, target: MAIN_TARGET)
      build_for(
        scheme: scheme,
        configuration: config,
        output_name: output,
        app_identifier: alt_app_id,
        extension_identifier: alt_ext_id
      )
      upload_for(output_name: output, distribute_external: false)
    ensure
      begin
        delete_keychain(name: KEYCHAIN_NAME)
      rescue
      end
    end
  end
end
