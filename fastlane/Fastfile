# Fastfile
default_platform(:ios)

platform :ios do
  # Constants
  APP_IDENTIFIER = "eu.peernetwork.PeerApp"
  EXTENSION_IDENTIFIER = "eu.peernetwork.PeerApp.PayloadModification"
  MAIN_TARGET = "PeerApp"
  EXTENSION_TARGET = "PayloadModification"
  SCHEME = "PeerApp"
  OUTPUT_NAME = "PeerApp"
  OUTPUT_DIR  = "build"
  KEYCHAIN_NAME = "signing"
  KEYCHAIN_PASSWORD = "temp"
  ROOT_DIR = File.expand_path("..", __dir__)
  VERSION_NOTES_PATH_DEFAULT = File.join(ROOT_DIR, "PeerApp", "Embeds", "version_history.json")

  before_all do
    sh("mkdir -p #{OUTPUT_DIR}")
  end

  desc "Load ASC API Key information to use in subsequent lanes"
  lane :load_asc_api_key do
    app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_PRIVATE_KEY"],
      is_key_content_base64: true,
      in_house: false
    )
  end

  desc "Get release notes for current version from JSON"
  lane :notes_from_json do
    require "json"
    current_version = get_version_number(target: MAIN_TARGET)

    path = (ENV["VERSION_NOTES_PATH"] && !ENV["VERSION_NOTES_PATH"].empty?) ? ENV["VERSION_NOTES_PATH"] : VERSION_NOTES_PATH_DEFAULT
    unless File.exist?(path)
      UI.user_error!("version_history.json not found at #{path}. Current dir: #{Dir.pwd}")
    end

    json = JSON.parse(File.read(path))
    entry = json.find { |e| e["version"].to_s.strip == current_version.to_s.strip }

    if entry.nil? || entry["releaseNotes"].nil?
      UI.important("No notes found for version #{current_version} in #{path}")
      next ""
    end

    "- " + entry["releaseNotes"].map(&:to_s).join("\n- ")
  end

  desc "Bump build number based on most recent TestFlight build number"
  lane :fetch_and_increment_build_number do
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]
    current_version = get_version_number(target: MAIN_TARGET)

    begin
      latest_build_number = latest_testflight_build_number(
        api_key: api_key,
        version: current_version,
        app_identifier: APP_IDENTIFIER
      )
      new_build_number = latest_build_number ? (latest_build_number + 1) : 1
    rescue => e
      UI.message("Error fetching build number: #{e}, defaulting to 1")
      new_build_number = 1
    end

    increment_build_number(
      build_number: new_build_number.to_s,
      xcodeproj: "#{MAIN_TARGET}.xcodeproj"
    )
  end
  
  desc "Installs signing certificate and provisioning profiles"
  lane :prepare_signing do
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]

    # Create a fresh temporary keychain
    begin
      delete_keychain(name: KEYCHAIN_NAME)
    rescue
    end

    create_keychain(
      name: KEYCHAIN_NAME,
      password: KEYCHAIN_PASSWORD,
      default_keychain: true,
      unlock: true,
      timeout: 3600
    )

    import_certificate(
      certificate_path: ENV["SIGNING_KEY_FILE_PATH"],
      certificate_password: ENV["SIGNING_KEY_PASSWORD"],
      keychain_name: KEYCHAIN_NAME,
      keychain_password: KEYCHAIN_PASSWORD
    )

    # Fetch and install provisioning profiles from ASC
    sigh(api_key: api_key, app_identifier: APP_IDENTIFIER, readonly: false)
    @main_profile_name = lane_context[SharedValues::SIGH_NAME]

    sigh(api_key: api_key, app_identifier: EXTENSION_IDENTIFIER, readonly: false)
    @extension_profile_name = lane_context[SharedValues::SIGH_NAME]
  end

  desc "Build the iOS app for release"
  lane :build_release do
    # Explicit code signing for both targets
    update_code_signing_settings(
      use_automatic_signing: false,
      targets: [MAIN_TARGET],
      code_sign_identity: "Apple Distribution",
      bundle_identifier: APP_IDENTIFIER,
      profile_name: @main_profile_name,
      build_configurations: ["Release"]
    )

    update_code_signing_settings(
      use_automatic_signing: false,
      targets: [EXTENSION_TARGET],
      code_sign_identity: "Apple Distribution",
      bundle_identifier: EXTENSION_IDENTIFIER,
      profile_name: @extension_profile_name,
      build_configurations: ["Release"]
    )
        
    # Build the app
    gym(
      scheme: SCHEME,
      output_name: OUTPUT_NAME,
      output_directory: OUTPUT_DIR,
      configuration: "Release",
      clean: true,
      silent: false,
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          APP_IDENTIFIER => @main_profile_name,
          EXTENSION_IDENTIFIER => @extension_profile_name
        }
      }
    )
  end

  desc "Upload to TestFlight (internal only)"
  lane :upload_release do
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]
    notes = notes_from_json

    upload_to_testflight(
      api_key: api_key,
      ipa: File.join(OUTPUT_DIR, "#{OUTPUT_NAME}.ipa"),
      skip_waiting_for_build_processing: false,
      distribute_external: false,
      changelog: notes
    )
  end
  
  desc "Build and upload to TestFlight"
  lane :build_upload_testflight do
    begin
      load_asc_api_key
      prepare_signing
      fetch_and_increment_build_number
      build_release
      upload_release
    ensure
      begin
        delete_keychain(name: KEYCHAIN_NAME)
      rescue
      end
    end
  end
end
