# Fastfile
default_platform(:ios)

platform :ios do
  # Constants
  APP_IDENTIFIER = "eu.peernetwork.PeerApp"
  EXTENSION_IDENTIFIER = "eu.peernetwork.PeerApp.PayloadModification"
  MAIN_TARGET = "PeerApp"
  EXTENSION_TARGET = "PayloadModification"
  SCHEME = "PeerApp"
  OUTPUT_NAME = "PeerApp"
  OUTPUT_DIR  = "build"
  KEYCHAIN_NAME = "signing"
  KEYCHAIN_PASSWORD = "temp"
  ROOT_DIR = File.expand_path("..", __dir__)
  VERSION_NOTES_PATH_DEFAULT = File.join(ROOT_DIR, "PeerApp", "Embeds", "version_history.json")

  before_all do
    sh("mkdir -p #{OUTPUT_DIR}")
  end

  desc "Load ASC API Key information to use in subsequent lanes"
  lane :load_asc_api_key do
    app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_PRIVATE_KEY"],
      is_key_content_base64: true,
      in_house: false
    )
  end

  desc "Get release notes for current version from JSON"
  lane :notes_from_json do
    require "json"
    current_version = get_version_number(target: MAIN_TARGET)
  
    # Allow override via env VERSION_NOTES_PATH, else use default
    path = (ENV["VERSION_NOTES_PATH"] && !ENV["VERSION_NOTES_PATH"].empty?) ? ENV["VERSION_NOTES_PATH"] : VERSION_NOTES_PATH_DEFAULT
  
    unless File.exist?(path)
      UI.user_error!("version_history.json not found at #{path}. Current dir: #{Dir.pwd}")
    end
  
    json = JSON.parse(File.read(path))
    entry = json.find { |e| e["version"].to_s.strip == current_version.to_s.strip }
  
    if entry.nil? || entry["releaseNotes"].nil?
      UI.important("No notes found for version #{current_version} in #{path}")
      next ""
    end
  
    "- " + entry["releaseNotes"].map(&:to_s).join("\n- ")
  end

  desc "Bump build number based on most recent TestFlight build number"
  lane :fetch_and_increment_build_number do
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]
    current_version = get_version_number(target: MAIN_TARGET)

    begin
      latest_build_number = latest_testflight_build_number(
        api_key: api_key,
        version: current_version,
        app_identifier: APP_IDENTIFIER
      )
      new_build_number = latest_build_number ? (latest_build_number + 1) : 1
    rescue => e
      UI.message("Error fetching build number: #{e}, defaulting to 1")
      new_build_number = 1
    end

    increment_build_number(
      build_number: new_build_number.to_s,
      xcodeproj: "#{MAIN_TARGET}.xcodeproj"
    )
  end
  
  desc "Installs signing certificate and provisioning profiles"
  lane :prepare_signing do
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]
    
    # Create a fresh temporary keychain
    begin
      delete_keychain(name: KEYCHAIN_NAME)
    rescue
      # ignore if missing
    end

    create_keychain(
      name: KEYCHAIN_NAME,
      password: KEYCHAIN_PASSWORD,
      default_keychain: true,
      unlock: true,
      timeout: 3600
    )

    import_certificate(
      certificate_path: ENV["SIGNING_KEY_FILE_PATH"],
      certificate_password: ENV["SIGNING_KEY_PASSWORD"],
      keychain_name: KEYCHAIN_NAME,
      keychain_password: KEYCHAIN_PASSWORD
    )

    # Fetch and install provisioning profiles from ASC
    sigh(
      api_key: api_key,
      app_identifier: APP_IDENTIFIER,
      readonly: false
    )
    @main_profile_name = lane_context[SharedValues::SIGH_NAME]

    sigh(
      api_key: api_key,
      app_identifier: EXTENSION_IDENTIFIER,
      readonly: false
    )
    @extension_profile_name = lane_context[SharedValues::SIGH_NAME]
  end

  desc "Build the iOS app for release"
  lane :build_release do 
    # Explicit code signing for both targets
    update_code_signing_settings(
      use_automatic_signing: false,
      targets: [MAIN_TARGET],
      code_sign_identity: "Apple Distribution",
      bundle_identifier: APP_IDENTIFIER,
      profile_name: @main_profile_name,
      build_configurations: ["Release"]
    )

    update_code_signing_settings(
      use_automatic_signing: false,
      targets: [EXTENSION_TARGET],
      code_sign_identity: "Apple Distribution",
      bundle_identifier: EXTENSION_IDENTIFIER,
      profile_name: @extension_profile_name,
      build_configurations: ["Release"]
    )
        
    # Build the app
    gym(
      scheme: SCHEME,
      output_name: OUTPUT_NAME,
      output_directory: OUTPUT_DIR,
      configuration: "Release",
      clean: true,
      silent: false,
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          APP_IDENTIFIER => @main_profile_name,
          EXTENSION_IDENTIFIER => @extension_profile_name
        }
      }
    )
  end

  private_lane :assign_build_to_internal_groups do |options|
    group_names = Array(options[:group_names]).map { |n| n.to_s.strip }.reject(&:empty?)
    next if group_names.empty?
  
    fastlane_require "spaceship"
  
    # Token already set by app_store_connect_api_key
    app = Spaceship::ConnectAPI::App.find(APP_IDENTIFIER) or UI.user_error!("App not found: #{APP_IDENTIFIER}")
  
    # Resolve groups by exact name (internal groups)
    groups = group_names.map do |name|
      (app.get_beta_groups(filter: { name: name }) || []).first or UI.user_error!("Internal TestFlight group not found: #{name}")
    end
  
    current_version = get_version_number(target: MAIN_TARGET)
    # read the build number we just set (same one archived & uploaded)
    current_build_number = get_build_number(xcodeproj: "#{MAIN_TARGET}.xcodeproj", target: MAIN_TARGET).to_s
  
    UI.message("Looking up build version=#{current_version} build_number=#{current_build_number} to attach groups: #{group_names.join(', ')}")
  
    # Robust lookup without fragile filters – fetch recent builds and match in Ruby
    build = nil
    retries = 12         # up to ~2 minutes total
    sleep_seconds = 10
  
    retries.times do |i|
      builds = app.get_builds(sort: "-uploadedDate", limit: 50) || []
      build = builds.find { |b| b.version.to_s == current_version.to_s && b.build_number.to_s == current_build_number }
      break if build
  
      UI.message("Build not visible yet (attempt #{i + 1}/#{retries})…")
      sleep(sleep_seconds)
    end
  
    unless build
      # Last-ditch fallback: take the newest build with the same marketing version
      builds_for_version = (app.get_builds(sort: "-uploadedDate", limit: 50) || []).select { |b| b.version.to_s == current_version.to_s }
      build = builds_for_version.first
    end
  
    UI.user_error!("Could not find uploaded build #{current_version} (#{current_build_number}) in App Store Connect") unless build
  
    UI.message("Assigning build #{build.version} (#{build.build_number}) to internal groups: #{group_names.join(', ')}")
    build.add_beta_groups(beta_groups: groups)
    UI.success("Assigned build to internal groups ✔︎")
  end

  desc "Upload to TestFlight (internal only) + assign internal groups"
  lane :upload_release do
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]

    notes = notes_from_json

    upload_to_testflight(
      api_key: api_key,
      ipa: File.join(OUTPUT_DIR, "#{OUTPUT_NAME}.ipa"),
      skip_waiting_for_build_processing: false,
      distribute_external: false,
      changelog: notes
    )

    internal_groups = (ENV["INTERNAL_TF_GROUPS"] || "")
      .split(",").map(&:strip).reject(&:empty?)

    assign_build_to_internal_groups(group_names: internal_groups) unless internal_groups.empty?
  end
  
  desc "Build and upload to TestFlight"
  lane :build_upload_testflight do
    begin
      load_asc_api_key
      prepare_signing
      fetch_and_increment_build_number
      build_release
      upload_release
    ensure
      # Cleanup keychain even if something failed
      begin
        delete_keychain(name: KEYCHAIN_NAME)
      rescue
        # ignore
      end
    end
  end
end
